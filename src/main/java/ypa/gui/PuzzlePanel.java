package ypa.gui;

import java.awt.*;
import java.awt.event.MouseEvent;
import java.util.Collection;
import java.util.HashSet;
import java.util.Set;

import ypa.model.KCell;
import ypa.model.KEntry;
import ypa.model.KPuzzle;

/**
 * A graphical view on a Hidato puzzle state.
 * This class handles the rendering of the Hidato puzzle grid and cells,
 * as well as user interactions through mouse events.
 *
 * @author Tom Verhoeff (Eindhoven University of Technology)
 * @updated By <Your Name> - description of the update
 */
public class PuzzlePanel extends javax.swing.JPanel {

    /**
     * Creates new form PuzzlePanel.
     */
    public PuzzlePanel() {
        initComponents();
        initPanel();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated
    // Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
                layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                        .addGap(0, 400, Short.MAX_VALUE));
        layout.setVerticalGroup(
                layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                        .addGap(0, 300, Short.MAX_VALUE));
    }// </editor-fold>//GEN-END:initComponents

    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables

    // Class variables

    // Size of each cell in the puzzle
    private final int cellSize = 35;
    // TODO: Consider making the cell size changeable by user

    final int offsetX = cellSize; // Horizontal margin
    final int offsetY = cellSize; // Vertical margin

    /** The puzzle being manipulated */
    private KPuzzle puzzle;

    /** Selected cell, affected by keystrokes. */
    private KCell selected;

    /** Whether symbols are highlighted */
    private boolean highlight;

    /** Marked cells (by different background color) */
    private Set<KCell> markedCells;

    /**
     * Initializes this panel.
     */
    private void initPanel() {
        setPuzzle(null);
        highlight = true;
    }

    /**
     * Sets the puzzle.
     *
     * @param puzzle the puzzle
     */
    public void setPuzzle(final KPuzzle puzzle) {
        this.puzzle = puzzle;
        this.selected = null;
        this.markedCells = null;
    }

    /**
     * Gets selected cell.
     *
     * @return the selected cell
     */
    public KCell getSelected() {
        return selected;
    }

    /**
     * Sets selected cell.
     *
     * @param cell the selected cell
     */
    public void setSelected(final KCell cell) {
        this.selected = cell;
    }

    /**
     * Sets whether to highlight the marked cells.
     *
     * @param newState the new highlighting state
     */
    public void setHighlight(final boolean newState) {
        this.highlight = newState;
    }

    /**
     * Sets the marked cells, which will be highlighted if enabled.
     *
     * @param markedCells the cells to mark, or {@code null} if none
     */
    public void setMarkedCells(final Collection<KCell> markedCells) {
        if (markedCells == null) {
            this.markedCells = new HashSet<>();
        } else {
            this.markedCells = new HashSet<>(markedCells);
        }
    }

    /**
     * /**
     * Draws given cell on given canvas at given location.
     *
     * @param g       Graphics object to draw on
     * @param cell    cell to draw
     * @param x       x-coordinate for bottom left corner of cell
     * @param y       y-coordinate for bottom left corner of cell
     * @param delta_x x-offset for digit within cell
     * @param delta_y y-offset for digit within cell
     */
    private void paintCell(final Graphics g, final KCell cell, final int x, final int y, final int delta_x,
            final int delta_y) {
        paintCellBackground(g, cell, x, y);
        paintCellContent(g, cell, x, y, delta_x, delta_y);
    }

    private void paintCellBackground(Graphics g, KCell cell, int x, int y) {
        // Check if the cell is marked and highlight accordingly
        if (highlight && markedCells != null && markedCells.contains(cell)) {
            g.setColor(Color.CYAN);
            g.fillRect(x + 1, y - cellSize + 1, cellSize - 1, cellSize - 1);
        }

        // Highlight the selected cell
        if (selected != null && cell == selected) {
            g.setColor(Color.YELLOW);
            g.fillRect(x + 1, y - cellSize + 1, cellSize - 1, cellSize - 1);
        }

        // If the cell is blocked, paint it black
        if (cell.isBlocked()) {
            g.setColor(Color.BLACK);
            g.fillRect(x + 1, y - cellSize + 1, cellSize - 1, cellSize - 1);
        }
    }

    private void paintCellContent(Graphics g, KCell cell, int x, int y, int delta_x, int delta_y) {
        // Only proceed if the cell is not blocked and not empty
        if (!cell.isBlocked() && !cell.isEmpty()) {
            // Set the color based on the cell state
            Color color = Color.BLACK;
            if (highlight) {
                if (!cell.isOK()) {
                    color = Color.RED;
                } else if (puzzle.isSolved()) {
                    color = Color.GREEN;
                }
            }
            g.setColor(color);

            // Draw the cell's content
            g.drawString(cell.toString(), x + delta_x, y - delta_y);
        }
    }

    @Override
    public void paintComponent(Graphics g) {
        super.paintComponent(g);
        prepareGraphics(g);

        if (puzzle == null) {
            drawEmptyPuzzleMessage(g);
            return;
        }

        drawPuzzleGrid(g);
        drawCells(g, g.getFontMetrics());

        // draw entries sums
        // g.setColor(Color.WHITE);
        // g.setFont(new Font("Lucida Sans Typewriter", Font.PLAIN, 12));
        // for (KEntry entry : puzzle.getEntries()) {
        // final int row; // row index of cell to show sum of entry
        // final int column; // column index of cell to show sum of entry
        // final int x; // x-coordinate of bottom-left corner
        // final int y; // y-coordinate of bottom-left corner
        // final int dx; // x-offset for showing sum
        // final int dy; // y-offset for showing sum
        // switch (entry.getDirection()) {
        // case HORIZONTAL -> {
        // row = entry.getLocation().getRow();
        // column = entry.getLocation().getColumn() - 1;
        // dx = cellSize / 2 + 1;
        // dy = cellSize / 2 + 1;
        // }
        // case VERTICAL -> {
        // row = entry.getLocation().getRow() - 1;
        // column = entry.getLocation().getColumn();
        // dx = cellSize / 8 + 1;
        // dy = cellSize / 8 - 1;
        // }
        // default -> throw new IllegalStateException(getClass().getSimpleName()
        // + ".paintComponent(): bad direction");
        // }
        // x = column * cellSize + offsetX;
        // y = (row + 1) * cellSize + offsetY;
        // // draw sum, in smaller font
        // final int sum = entry.getSpecification().getSum();
        // g.drawString(String.format("%2d", sum), x + dx, y - dy);
        // }
    }

    private void drawPuzzleGrid(Graphics g) {
        final int WIDTH = cellSize * puzzle.getColumnCount();
        final int HEIGHT = cellSize * puzzle.getRowCount();

        g.setColor(Color.WHITE);
        g.fillRect(cellSize, cellSize, WIDTH, HEIGHT);
        g.setColor(java.awt.Color.BLACK);

        // Draw horizontal and vertical separator lines
        for (int r = 0; r <= puzzle.getRowCount(); ++r) {
            final int y = r * cellSize + offsetY;
            g.drawLine(offsetX, y, WIDTH + offsetX, y);
        }
        for (int c = 0; c <= puzzle.getColumnCount(); ++c) {
            final int x = c * cellSize + offsetX;
            g.drawLine(x, offsetY, x, HEIGHT + offsetY);
        }
    }

    private void drawCells(Graphics g, FontMetrics fm) {
        for (int r = 0; r != puzzle.getRowCount(); ++r) {
            final int y = (r + 1) * cellSize + offsetY;
            for (int c = 0; c != puzzle.getColumnCount(); ++c) {
                final int x = c * cellSize + offsetX;
                final KCell cell = puzzle.getCell(r, c);

                int textWidth = fm.stringWidth(cell.toString());
                int textHeight = fm.getAscent();
                int delta_x = (cellSize - textWidth) / 2 + 1;
                int delta_y = (cellSize - textHeight + fm.getDescent()) / 2;

                paintCell(g, cell, x, y, delta_x, delta_y);
            }
        }
    }

    private void prepareGraphics(Graphics g) {
        g.setColor(java.awt.Color.DARK_GRAY);
        g.fillRect(0, 0, this.getWidth(), this.getHeight());

        Font font = new Font("Lucida Sans Typewriter", Font.BOLD, 24);
        FontMetrics fm = g.getFontMetrics(font);
        int maxNumberWidth = fm.charWidth('0') * 2; // Maximum width for two digits

        if (maxNumberWidth > cellSize) {
            float fontSize = font.getSize() * ((float) cellSize / maxNumberWidth);
            font = font.deriveFont(fontSize);
        }
        g.setFont(font);
    }

    private void drawEmptyPuzzleMessage(Graphics g) {
        g.setColor(Color.YELLOW);
        String message = "No puzzle loaded";
        FontMetrics fm = g.getFontMetrics();
        int messageWidth = fm.stringWidth(message);
        int x = (getWidth() - messageWidth) / 2;
        int y = getHeight() / 2;
        g.drawString(message, x, y);
    }

    /**
     * Returns cell in grid for a given mouse event.
     *
     * @param evt the mouse event
     * @return cell in grid at {@code evt}, or {@code null} if non-existent
     * @pre {@code evt != null}
     */
    public KCell mouseToCell(final MouseEvent evt) {
        if (puzzle == null) {
            return null;
        }
        final int row = (evt.getY() - offsetY) / cellSize;
        final int col = (evt.getX() - offsetX) / cellSize;
        // System.out.println("Clicked row: " + row + ", column: " + col + " "
        // + puzzle.has(row, col)); // De
        if (puzzle.has(row, col)) {
            return puzzle.getCell(row, col);
        } else {
            return null;
        }
    }

}
